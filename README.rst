otpmanager
===========

``otpmanager`` provides the ``OTPManager`` class that manages the setup,
startup, and monitoring of an `OpenTripPlanner
<http://www.opentripplanner.org/>`_ (OTP) instance. This is meant to be used in
conjuction with `route_distances <https://github.com/ercas/route_distances>`_,
a library to interface with various routing engines from Python, including OTP.

OTPManager's functionality includes:

* Downloading the necessary OSM XML file using the
  `Overpass API <https://wiki.openstreetmap.org/wiki/Overpass_API>`_
* Finding GTFS feeds using the `Transitland API <https://transit.land/>`_ and
  downloading them
* Building the ``Graph.obj`` using OTP
* Running an OTP router using the generated graph, dynamically allocating ports
  if specified (default behaviour)
* For all steps involving OTP, monitor progress and terminating OTP if it
  freezes or encounters an error
* Provide access to the OTP subprocess and information about it
* Automatically shutting down OTP to free up resources when the script exits

**Important caveats**:

* OpenJDK 8 JRE must be used instead of OpenJDK 9 JRE. OpenJDK 9 produces an
  obscure error with the `GeoTools <http://www.geotools.org/>`_ library when
  building the graph.
* As of commit ``5c31ab1``, otpmanager creates ``otpmanager*.log`` files during
  runtime. It is important to not remove these files while otpmanager is
  running because these files are how otpmanager checks the status of the
  running OTP instance. otpmanager previously read directly from the OTP
  process's standard streams via ``subprocess.PIPE``, but this created a race
  condition where the pipe had the potential to deadlock if OTP wrote data
  faster than the monitor process could consume it.

Simple usage, paired with ``route_distances``:

.. code-block:: python

    import otpmanager
    import route_distances

    manager = otpmanager.OTPManager(
        "boston", -71.191155, 42.227926, -70.748802, 42.400819999999996,
        otp_path = "./otp-1.1.0-shaded.jar"
    )
    manager.start()

    # Here we use manager.port to find what port OTP was bound to because it was
    # dynamically allocated, so we can't be sure what port it is. This behaviour
    # can be overridden if necessary.
    router = route_distances.OTPDistances("localhost:%d" % manager.port)
    print(router.route(-71.08930, 42.33877, -71.07743, 42.34954, "walk"))

    manager.terminate()

    # We can also use GraphHopper
    manager = otpmanager.GraphHopperManager(
        "boston", -71.191155, 42.227926, -70.748802, 42.400819999999996,
        otp_path = "./otp-1.1.0-shaded.jar"
    )
    manager.start()

    router = route_distances.GraphHopperDistances("localhost:%d" % manager.port)
    print(router.route(-71.08930, 42.33877, -71.07743, 42.34954, "walk"))

    manager.terminate()

..

By default, OTPManager.start() downloads an OSM file containing only nodes used
in ways (no points of interest), and considers a download "failed" if it its
size is less than 10kb. This is because the Overpass API will return a valid
file containing only an error message and no OSM contents if an API call fails.
This behaviour can be toggled by passing ``ways_only = False`` and ``min_osm_size
= NUMBER`` to OTPManager.start().

Note that this is in contrast to ``otpmanager.bbox_dl.overpass_dl()``'s default
behaviour when run on its own, which is to download everything within a
bounding box. For large routing operations, this is not possible because of
the amount of data in a bounding box may exceed what the Overpass API can
return.

For more fine-grained control, ``otpmanager`` also provides the following
internal methods that each control a portion of the OTP startup process:

* ``download_osm``: Download the .osm file
* ``download_gtfs``: Download the GTFS feeds
* ``build_graph``: Attempt to build the graph with OTP
* ``start_otp``: Starts OTP, using the files generated by ``download_osm``,
  ``download_gtfs``, and ``build_graph``

Additionally, the behaviour of OTP can be monitored using the ``monitor_otp``
method. This function monitors the STDERR and STDOUT messages of OTP and
performs tasks when certain substrings appear in those messages. See
``otpmanager/manager.py`` for more info.
